// imports
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { pipeline } = require('node:stream');

// user controlled settings
const password = 'this-password-is-secure';

// code
function encrypt() {
    return new Promise(function (resolve, reject) {
        // input stream ( source of the data we want to encrypt )
        const inputStream = fs.createReadStream(path.join(__dirname, 'file-to-encrypt.txt'));

        // output stream ( destination of the data we encrypted )
        const outputStream = fs.createWriteStream(path.join(__dirname, 'file-encrypted.txt'));

        // key ( we will need a 256 bit key to use aes-256 encryption )
        //
        // we will use a very simple KDF (Key Derivation Function) for demo purpose
        // in a production environment a better KDF should be used!
        //
        // some exmaples would be:
        // - PBKDF2 (crypto.pbkdf2(password, salt, iterations, keylen, digest, callback))
        // - SCrypt (crypto.scrypt(password, salt, keylen[, options], callback))
        // - Argon2 in PBKDF mode (https://www.npmjs.com/package/argon2)
        //
        // Why is a good KDF necessary? https://stackoverflow.com/a/55091603
        const key = crypto.createHash('sha256').update(password).digest();

        // iv ( initial vector used for the encryption algorithm )
        // safest is to just generate some random iv using a good
        // cryptographically secure pseudo random number generator
        //
        // crypto.randomBytes() is a very secure method
        //
        // further read: https://stackoverflow.com/a/43033592
        const iv = crypto.randomBytes(16);

        // cypher ( the cypher we will use to encrypt the data )
        // we will use the AES ( Advanced Encryption Standard ) algorithm
        // we will use a 256 bit ( 32 bytes ) long key for the algorithm
        // we will use the algorithm in CTR ( Counter ) mode
        // we will give the algorithm our generated iv and derived key
        const cypher = crypto.createCipheriv('aes-256-ctr', key, iv);

        // the iv can be published it only needs to be unpredictable random
        // when we encode the data to prevent attacks on the cipher algorithm
        // we will need the iv to decrypt the data later so we prepend it to
        // the encrypted output
        //
        // further read: https://crypto.stackexchange.com/a/3970
        outputStream.write(iv);

        // now we pipe the input stream through the cypher stream
        // and pipe the final product to the output stream.
        pipeline(inputStream, cypher, outputStream, function (error) {
            if (error) {
                reject(error);
                return;
            }

            console.log('Encrpytion: Done');
            resolve();
        });
    });
}

function decrypt() {
    return new Promise(function (resolve, reject) {
        // input stream ( source of the data we want to decrypt )
        // we will start reading from byte 16 to skip the iv we prepended
        const inputStream = fs.createReadStream(path.join(__dirname, 'file-encrypted.txt'), {
            start: 16,
        });

        // output stream ( destination of the data we decrypted )
        const outputStream = fs.createWriteStream(path.join(__dirname, 'file-decrypted.txt'));

        // key ( we will need a 256 bit key to use aes-256 decryption )
        //
        // we will use a very simple KDF (Key Derivation Function) for demo purpose
        // in a production environment a better KDF should be used!
        //
        // some exmaples would be:
        // - PBKDF2 (crypto.pbkdf2(password, salt, iterations, keylen, digest, callback))
        // - SCrypt (crypto.scrypt(password, salt, keylen[, options], callback))
        // - Argon2 in PBKDF mode (https://www.npmjs.com/package/argon2)
        //
        // Why is a good KDF necessary? https://stackoverflow.com/a/55091603
        const key = crypto.createHash('sha256').update(password).digest();

        // iv ( initial vector used for the decryption algorithm )
        // we will read the iv generated by the encryption from the
        // encrypted file
        const iv = Buffer.alloc(16);
        const ivHandle = fs.openSync(path.join(__dirname, '/file-encrypted.txt'), 'r');
        fs.readSync(ivHandle, iv, 0, 16, 0);
        fs.closeSync(ivHandle);

        // cypher ( the cypher we will use to decrypt the data )
        // we will use the AES ( Advanced Encryption Standard ) algorithm
        // we will use a 256 bit ( 32 bytes ) long key for the algorithm
        // we will use the algorithm in CTR ( Counter ) mode
        // we will give the algorithm our received iv and derived key
        const cypher = crypto.createDecipheriv('aes-256-ctr', key, iv);

        // now we pipe the input stream through the cypher stream
        // and pipe the final product to the output stream.
        pipeline(inputStream, cypher, outputStream, function (error) {
            if (error) {
                reject(error);
                return;
            }

            console.log('Decryption: Done');
            resolve();
        });
    });
}

(async function () {
    // encrypt the file
    await encrypt();

    // decrypt the encrypted file
    await decrypt();

    console.log('-- DEMO RUN DONE --');
})();
